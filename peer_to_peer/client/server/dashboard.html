<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Network Packet Dashboard</title>
  <style>
    body { font-family: Arial, sans-serif; background: #181818; color: #fff; margin: 0; padding: 0; }
    .container { max-width: 1100px; margin: 2rem auto; background: #222; border-radius: 8px; padding: 2rem; box-shadow: 0 0 12px #000; }
    h1 { text-align: center; }
    table { width: 100%; border-collapse: collapse; margin-top: 2rem; background: #222; }
    th, td { padding: 0.5rem 0.7rem; border-bottom: 1px solid #333; text-align: left; }
    th { background: #333; }
    tr:last-child td { border-bottom: none; }
    .chart { margin: 2rem 0; }
    .charts-container { display: flex; justify-content: space-between; gap: 2rem; flex-wrap: wrap; }
    svg { background: #111; border-radius: 4px; }
  </style>
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
  <div class="container">
    <h1>Network Packet Dashboard</h1>

    <div class="charts-container">
      <div class="chart">
        <h3>Packets per Minute</h3>
        <svg id="throughputChart" width="500" height="200"></svg>
      </div>
      <div class="chart">
        <h3>Packet Latency (ms)</h3>
        <svg id="latencyChart" width="500" height="200"></svg>
      </div>
    </div>

    <table id="packetTable">
      <thead>
        <tr>
          <th>Seq</th>
          <th>Timestamp</th>
          <th>Protocol</th>
          <th>Source</th>
          <th>Destination</th>
          <th>Packet Size</th>
          <th>Type</th>
          <th>Latency (ms)</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <script>
    async function fetchPackets() {
      const res = await fetch('/packets');
      return res.json();
    }

    function renderTable(packets) {
      const tbody = document.querySelector('#packetTable tbody');
      tbody.innerHTML = '';
      packets.slice(-100).reverse().forEach(pkt => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${pkt.sequence}</td>
          <td>${new Date(pkt.timestamp).toLocaleTimeString()}</td>
          <td>${pkt.protocol || pkt.type}</td>
          <td>${pkt.src || pkt.socketId}</td>
          <td>${pkt.dst || 'server'}</td>
          <td>${pkt.size}</td>
          <td>${pkt.type}</td>
          <td>${pkt.latency != null ? pkt.latency : '-'}</td>
        `;
        tbody.appendChild(tr);
      });
    }

    function renderThroughputChart(packets) {
      const svg = d3.select('#throughputChart'); // id correto
      svg.selectAll('*').remove();
      const width = +svg.attr('width');
      const height = +svg.attr('height');

      const now = Date.now();
      const MINUTES = 10; // Ãºltimos 10 minutos
      const bins = Array(MINUTES).fill(0);

      packets.forEach(pkt => {
        const minAgo = Math.floor((now - pkt.timestamp) / 60000);
        if (minAgo < MINUTES && minAgo >= 0) bins[MINUTES - 1 - minAgo]++;
      });

      const x = d3.scaleLinear().domain([0, MINUTES-1]).range([40, width-20]);
      const y = d3.scaleLinear().domain([0, d3.max(bins) || 1]).range([height-30, 20]);

      // Eixo X
      svg.append('g')
        .attr('transform', `translate(0,${height-30})`)
        .call(d3.axisBottom(x).ticks(MINUTES).tickFormat(i => `${MINUTES-1-i}m ago`));

      // Eixo Y
      svg.append('g')
        .attr('transform', 'translate(40,0)')
        .call(d3.axisLeft(y));

      // Barras
      svg.selectAll('rect')
        .data(bins)
        .enter()
        .append('rect')
        .attr('x', (d,i) => x(i)-10)
        .attr('y', d => y(d))
        .attr('width', 18)
        .attr('height', d => height-30-y(d))
        .attr('fill', '#38b000');
    }


    function renderLatencyChart(packets) {
      const svg = d3.select('#latencyChart');
      svg.selectAll('*').remove();
      const width = +svg.attr('width');
      const height = +svg.attr('height');

      const recent = packets.filter(pkt => pkt.latency != null).slice(-50);
      if (recent.length === 0) return;

      const x = d3.scaleLinear().domain([0, recent.length - 1]).range([40, width-20]);
      const y = d3.scaleLinear().domain([0, d3.max(recent, d => d.latency)]).range([height-30, 20]);

      const line = d3.line()
        .x((d,i) => x(i))
        .y(d => y(d.latency))
        .curve(d3.curveMonotoneX);

      svg.append('g').attr('transform',`translate(0,${height-30})`).call(d3.axisBottom(x).ticks(5));
      svg.append('g').attr('transform','translate(40,0)').call(d3.axisLeft(y));

      svg.append('path')
        .datum(recent)
        .attr('fill','none')
        .attr('stroke','#ffb703')
        .attr('stroke-width',2)
        .attr('d', line);

      // Optional: draw points
      svg.selectAll('circle')
        .data(recent)
        .enter()
        .append('circle')
        .attr('cx',(d,i)=>x(i))
        .attr('cy',d=>y(d.latency))
        .attr('r',3)
        .attr('fill','#ffb703');
    }

    async function update() {
      const packets = await fetchPackets();
      renderTable(packets);
      renderThroughputChart(packets);
      renderLatencyChart(packets);
    }

    setInterval(update, 1000);
    update();
  </script>
</body>
</html>
